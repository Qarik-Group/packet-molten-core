etcd:
  # All options get passed as command line flags to etcd.
  # Any information inside curly braces comes from the machine at boot time.

  # multi_region and multi_cloud deployments need to use {PUBLIC_IPV4}
  advertise_client_urls:       "http://{PRIVATE_IPV4}:2379"
  initial_advertise_peer_urls: "http://{PRIVATE_IPV4}:2380"
  # listen on both the official ports and the legacy ports
  # legacy ports can be omitted if your application doesn't depend on them
  listen_client_urls:          "http://0.0.0.0:2379"
  listen_peer_urls:            "http://{PRIVATE_IPV4}:2380"
  # generate a new token for each unique cluster from https://discovery.etcd.io/new?size=3
  # specify the initial size of your cluster with ?size=X
  discovery:                   "${discovery_url}"

locksmith:
  reboot_strategy: "etcd-lock"
  # reboot_strategy: reboot
  window_start: 01:00
  window_length: 1h

storage:
  files:
  - path: /var/ssl/docker/ca.pem
    filesystem: root
    mode: 0644
    user: { id: 500 }
    group: { id: 500 }
    contents:
      inline: |
        ${indent(8, docker_ca)}
  - path: /var/ssl/docker/key.pem
    filesystem: root
    mode: 0644
    user: { id: 500 }
    group: { id: 500 }
    contents:
      inline: |
        ${indent(8, docker_key)}
  - path: /var/ssl/docker/client.pem
    filesystem: root
    mode: 0644
    user: { id: 500 }
    group: { id: 500 }
    contents:
      inline: |
        ${indent(8, docker_client_cert)}
  - path: /opt/bin/bucc
    filesystem: root
    mode: 0755
    user: { id: 500 }
    group: { id: 500 }
    contents:
      inline: |
        #!/bin/bash
        docker run \
          --workdir /bucc \
          --mount type=bind,source=/var/lib/bucc,target=/bucc/state \
          --network bosh \
          --entrypoint /bin/bash -it rkoster/bucc

  - path: /opt/bin/bucc-wrapper
    filesystem: root
    mode: 0755
    user: { id: 500 }
    group: { id: 500 }
    contents:
      inline: |
        #!/bin/bash

        if hostname | grep -q -v 01; then
          echo "not the first cluster node"
          echo "skipping bucc install"
          exit 0
        fi

        IP=$(grep IPV4_PUBLIC /run/metadata/coreos | cut -d= -f2)
        CA=$(cat /var/ssl/docker/ca.pem)
        KEY=$(cat /var/ssl/docker/key.pem)
        CERT=$(cat /var/ssl/docker/client.pem)

        export VARS=$(jq -n -c -r \
          --arg ip "$IP" \
          --arg ca "$CA" \
          --arg cert "$CERT" \
          --arg key "$KEY" \
          '{
            director_name: "bucc",
            docker_host: "tcp://\($ip):2376",
            internal_cidr: "10.1.0.0/24",
            internal_ip: "10.1.0.10",
            internal_gw: "10.1.0.1",
            concourse_domain: $ip,
            network: "bosh",
            docker_tls: {
              ca: $ca,
              certificate: $cert,
              private_key: $key,
            }
          } | @base64')

        set -x

        /usr/bin/rkt run \
          --dns=8.8.4.4 \
          --net=host \
          --volume sw-bucc-state,kind=host,source=/var/lib/bucc,readOnly=false \
          --mount volume=sw-bucc-state,target=/bucc/state \
          --inherit-env --insecure-options=image \
          docker://rkoster/bucc --exec /bucc/entry.sh -- up --recreate --cpi docker --flannel --concourse-lb

systemd:
  units:
  - name: bucc.service
    enabled: true
    contents: |
      [Unit]
      Description=BUCC - BOSH UAA Credhub and Concourse
      After=docker.service
      Wants=docker.service
      Requires=docker.service

      [Service]
      Type=oneshot
      ExecStartPre=mkdir -p /var/lib/bucc
      ExecStart=/opt/bin/bucc-wrapper
      RemainAfterExit=true
      StandardOutput=journal

      [Install]
      WantedBy=multi-user.target
  - name: flanneld.service
    dropins:
    - name: 50-network-config.conf
      contents: |
        [Service]
        EnvironmentFile=/run/metadata/coreos
        ExecStartPre=/usr/bin/etcdctl set /coreos.com/network/config '{ "Network": "10.1.0.0/16" }'
        ExecStartPre=/usr/bin/etcdctl set /coreos.com/network/subnets/${flannel_cidr} "{\"PublicIP\":\"$${COREOS_PACKET_IPV4_PUBLIC_0}\"}"
  - name: docker-tls-tcp.socket
    enable: true
    contents: |
      [Unit]
      Description=Docker Secured Socket for the API

      [Socket]
      ListenStream=2376
      BindIPv6Only=both
      Service=docker.service

      [Install]
      WantedBy=sockets.target
  - name: docker.service
    dropins:
    - name: 60-disable-flannel-default-bridge.conf
      contents: |
        [Service]
        ExecStartPre=/bin/sh -c 'echo "" > /run/flannel/flannel_docker_opts.env'
    - name: 50-enable-tls.conf
      contents: |
        [Service]
        EnvironmentFile=/run/metadata/coreos
        Environment=DOCKER_CA=/var/ssl/docker/ca.pem
        Environment=DOCKER_CERT=/var/ssl/docker/cert.pem
        Environment=DOCKER_KEY=/var/ssl/docker/key.pem
        Environment=DOCKER_CSR=/var/ssl/docker/cert.csr
        Environment=DOCKER_EXTCNF=/var/ssl/docker/extfile.cnf
        ExecStartPre=openssl req -subj "/CN=$${COREOS_PACKET_IPV4_PUBLIC_0}" -sha256 -new -key $${DOCKER_KEY} -out $${DOCKER_CSR}
        ExecStartPre=/bin/sh -c 'echo "subjectAltName = IP:$${COREOS_PACKET_IPV4_PUBLIC_0},IP:127.0.0.1" > $${DOCKER_EXTCNF}'
        ExecStartPre=/bin/sh -c 'echo "extendedKeyUsage = serverAuth" >> $${DOCKER_EXTCNF}'
        ExecStartPre=openssl x509 -req -days 365 -sha256 -in $${DOCKER_CSR} -CA $${DOCKER_CA} -CAkey $${DOCKER_KEY} -CAcreateserial -out $${DOCKER_CERT} -extfile $${DOCKER_EXTCNF}

docker:
  flags:
    - --tlsverify
    - --tlscacert=/var/ssl/docker/ca.pem
    - --tlscert=/var/ssl/docker/cert.pem
    - --tlskey=/var/ssl/docker/key.pem

flannel: ~
